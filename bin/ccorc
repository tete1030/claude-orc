#!/usr/bin/env python3
"""
Session Management CLI Utility

Command-line tool for managing Claude Multi-Agent Orchestrator persistent contexts.
Provides session discovery, health monitoring, and cleanup capabilities.
"""

import argparse
import json
import subprocess
import sys
import re
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass, asdict
import os

# Add parent directory to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent))

# Import core TeamContextManager
try:
    from src.team_context_manager import TeamContextManager as CoreTeamContextManager, TeamContext, AgentInfo
except ImportError:
    print("Error: Could not import core TeamContextManager. Ensure team_context_manager.py is in path.", file=sys.stderr)
    sys.exit(1)


@dataclass
class ContainerInfo:
    """Information about a container"""
    name: str
    status: str
    created: str
    agent_role: str
    running: bool
    
    
@dataclass 
class ContextInfo:
    """Information about a team context"""
    name: str
    containers: List[ContainerInfo]
    tmux_session: Optional[str]
    created: Optional[str]
    total_containers: int
    running_containers: int
    

class SessionCLIManager:
    """CLI-specific session management with container discovery"""
    
    def __init__(self):
        self.container_prefix = "ccbox-"
        self.core_manager = CoreTeamContextManager()
        
    def discover_contexts(self) -> Dict[str, ContextInfo]:
        """Discover all team contexts from running containers"""
        contexts = {}
        
        try:
            # Get all ccbox containers
            result = subprocess.run([
                "docker", "ps", "-a", 
                "--filter", f"name={self.container_prefix}",
                "--format", "{{.Names}}\t{{.Status}}\t{{.CreatedAt}}"
            ], capture_output=True, text=True, check=True)
            
            for line in result.stdout.strip().split('\n'):
                if not line:
                    continue
                    
                parts = line.split('\t')
                if len(parts) < 3:
                    continue
                    
                container_name, status, created = parts[0], parts[1], parts[2]
                
                # Parse container name to extract session and role
                context_name, agent_role = self._parse_container_name(container_name)
                if not context_name:
                    continue
                    
                # Determine if container is running
                running = "Up" in status
                
                container_info = ContainerInfo(
                    name=container_name,
                    status=status,
                    created=created,
                    agent_role=agent_role,
                    running=running
                )
                
                # Add to session
                if context_name not in contexts:
                    contexts[context_name] = ContextInfo(
                        name=context_name,
                        containers=[],
                        tmux_session=None,
                        created=None,
                        total_containers=0,
                        running_containers=0
                    )
                
                contexts[context_name].containers.append(container_info)
                contexts[context_name].total_containers += 1
                if running:
                    contexts[context_name].running_containers += 1
                    
                # Set session creation time to earliest container
                if not contexts[context_name].created or created < contexts[context_name].created:
                    contexts[context_name].created = created
                    
            # Check for tmux sessions
            self._discover_tmux_sessions(contexts)
            
        except subprocess.CalledProcessError as e:
            print(f"Error discovering contexts: {e}", file=sys.stderr)
            
        return contexts
    
    def _parse_container_name(self, container_name: str) -> Tuple[Optional[str], Optional[str]]:
        """Parse container name to extract session name and agent role"""
        if not container_name.startswith(self.container_prefix):
            return None, None
            
        # Remove prefix: ccbox-session-role or ccbox-session-sub-role
        name_part = container_name[len(self.container_prefix):]
        
        # Find last dash to separate role from session name
        parts = name_part.split('-')
        if len(parts) < 2:
            return None, None
            
        # Agent role is the last part
        agent_role = parts[-1]
        # Session name is everything before the last dash
        context_name = '-'.join(parts[:-1])
        
        return context_name, agent_role
    
    def _discover_tmux_sessions(self, contexts: Dict[str, ContextInfo]):
        """Discover related tmux sessions"""
        try:
            result = subprocess.run([
                "tmux", "list-sessions", "-F", "#{session_name}"
            ], capture_output=True, text=True, check=True)
            
            tmux_sessions = result.stdout.strip().split('\n')
            
            for context_name in contexts:
                # Look for tmux session that matches or contains the team context name
                for tmux_session in tmux_sessions:
                    if tmux_session and (context_name in tmux_session or tmux_session in context_name):
                        contexts[context_name].tmux_session = tmux_session
                        break
                        
        except subprocess.CalledProcessError:
            # tmux might not be running or no sessions exist
            pass
    
    def get_context_details(self, context_name: str) -> Optional[ContextInfo]:
        """Get detailed information about a specific session"""
        # First check if session is registered
        try:
            registered = self.core_manager.list_contexts()
            if context_name not in registered:
                # Not a registered team context
                return None
                
            session_data = registered[context_name]
            
            # Get live container information for this session
            session_info = ContextInfo(
                name=context_name,
                containers=[],
                tmux_session=session_data.get('tmux_session'),
                created=session_data.get('created_at'),
                total_containers=0,
                running_containers=0
            )
            
            # Check each registered container
            for container_name in session_data.get('containers', []):
                try:
                    # Get container status
                    result = subprocess.run([
                        "docker", "ps", "-a", 
                        "--filter", f"name=^{container_name}$",
                        "--format", "{{.Names}}\t{{.Status}}\t{{.CreatedAt}}"
                    ], capture_output=True, text=True, check=True)
                    
                    if result.stdout.strip():
                        parts = result.stdout.strip().split('\t')
                        if len(parts) >= 3:
                            status = parts[1]
                            created = parts[2]
                            running = "Up" in status
                            
                            # Extract agent role from container name
                            agent_role = container_name.split('-')[-1]
                            
                            container_info = ContainerInfo(
                                name=container_name,
                                status=status,
                                created=created,
                                agent_role=agent_role,
                                running=running
                            )
                            
                            session_info.containers.append(container_info)
                            session_info.total_containers += 1
                            if running:
                                session_info.running_containers += 1
                                
                except subprocess.CalledProcessError:
                    pass
                    
            return session_info
            
        except Exception as e:
            print(f"Error getting session details: {e}", file=sys.stderr)
            return None
    
    def list_contexts(self) -> Dict[str, ContextInfo]:
        """List registered team contexts from the context registry"""
        contexts = {}
        
        try:
            # Get only registered contexts from core manager
            registered = self.core_manager.list_contexts()
            
            for name, session_data in registered.items():
                # Check container status for each registered session
                running = 0
                container_infos = []
                
                # Check each container in the registered session
                for container_name in session_data.get('containers', []):
                    # Quick check if container exists and is running
                    try:
                        result = subprocess.run([
                            "docker", "inspect", "-f", "{{.State.Running}}", container_name
                        ], capture_output=True, text=True, check=False)
                        
                        is_running = result.returncode == 0 and result.stdout.strip() == "true"
                        if is_running:
                            running += 1
                    except:
                        pass
                
                # Create ContextInfo for registered session
                contexts[name] = ContextInfo(
                    name=name,
                    containers=[],  # Don't populate full container list for simple listing
                    tmux_session=session_data.get('tmux_session'),
                    created=session_data.get('created_at'),
                    total_containers=len(session_data.get('containers', [])),
                    running_containers=running
                )
                
        except Exception as e:
            print(f"Warning: Could not load registry data: {e}", file=sys.stderr)
            
        return contexts
    
    def health_check_context(self, context_name: str) -> Dict[str, any]:
        """Perform health check on session components"""
        context = self.get_context_details(context_name)
        if not session:
            return {"error": f"Context '{context_name}' not found"}
            
        health_status = {
            "context_name": context_name,
            "overall_health": "healthy",
            "containers": {},
            "tmux_session": None,
            "issues": []
        }
        
        # Check container health
        for container in context.containers:
            container_health = self._check_container_health(container)
            health_status["containers"][container.name] = container_health
            
            if container_health["status"] != "healthy":
                health_status["overall_health"] = "degraded"
                health_status["issues"].extend(container_health.get("issues", []))
        
        # Check tmux session
        if context.tmux_session:
            tmux_health = self._check_tmux_health(context.tmux_session)
            health_status["tmux_session"] = tmux_health
            
            if tmux_health["status"] != "healthy":
                health_status["overall_health"] = "degraded"
                health_status["issues"].extend(tmux_health.get("issues", []))
        
        return health_status
    
    def _check_container_health(self, container: ContainerInfo) -> Dict[str, any]:
        """Check health of individual container"""
        health = {
            "name": container.name,
            "status": "healthy",
            "running": container.running,
            "claude_process": False,
            "session_files": False,
            "resource_usage": {},
            "issues": []
        }
        
        if not container.running:
            health["status"] = "stopped"
            health["issues"].append("Container is not running")
            return health
            
        try:
            # Check Claude process
            result = subprocess.run([
                "docker", "exec", container.name, "pgrep", "-f", "claude"
            ], capture_output=True, text=True)
            
            health["claude_process"] = result.returncode == 0
            if not health["claude_process"]:
                health["issues"].append("Claude process not found")
                health["status"] = "unhealthy"
            
            # Check session files
            result = subprocess.run([
                "docker", "exec", container.name, "test", "-f", "/home/developer/.claude.json"
            ], capture_output=True, text=True)
            
            health["session_files"] = result.returncode == 0
            if not health["session_files"]:
                health["issues"].append("Claude session files missing")
                
            # Check resource usage
            result = subprocess.run([
                "docker", "stats", "--no-stream", "--format", 
                "{{.CPUPerc}}\t{{.MemUsage}}", container.name
            ], capture_output=True, text=True)
            
            if result.returncode == 0 and result.stdout.strip():
                stats = result.stdout.strip().split('\t')
                if len(stats) >= 2:
                    health["resource_usage"] = {
                        "cpu_percent": stats[0],
                        "memory_usage": stats[1]
                    }
                    
        except subprocess.CalledProcessError:
            health["status"] = "error"
            health["issues"].append("Failed to check container health")
            
        return health
    
    def _check_tmux_health(self, tmux_session: str) -> Dict[str, any]:
        """Check health of tmux session"""
        health = {
            "context_name": tmux_session,
            "status": "healthy",
            "exists": False,
            "panes": 0,
            "issues": []
        }
        
        try:
            # Check if session exists
            result = subprocess.run([
                "tmux", "has-session", "-t", tmux_session
            ], capture_output=True, text=True)
            
            health["exists"] = result.returncode == 0
            
            if health["exists"]:
                # Count panes
                result = subprocess.run([
                    "tmux", "list-panes", "-t", tmux_session, "-F", "#{pane_index}"
                ], capture_output=True, text=True)
                
                if result.returncode == 0:
                    health["panes"] = len(result.stdout.strip().split('\n'))
                    
            else:
                health["status"] = "missing"
                health["issues"].append("Tmux session does not exist")
                
        except subprocess.CalledProcessError:
            health["status"] = "error"
            health["issues"].append("Failed to check tmux session")
            
        return health
    
    def cleanup_context(self, context_name: str, force: bool = False) -> bool:
        """Clean up a team context"""
        context = self.get_context_details(context_name)
        if not session:
            print(f"Context '{context_name}' not found")
            return False
            
        print(f"\nContext cleanup for: {context_name}")
        print(f"Containers to remove: {len(context.containers)}")
        for container in context.containers:
            print(f"  - {container.name} ({container.status})")
            
        if context.tmux_session:
            print(f"Tmux session to remove: {context.tmux_session}")
            
        if not force:
            confirm = input("\nThis will permanently delete all session data. Continue? (type 'yes'): ")
            if confirm.lower() != 'yes':
                print("Cleanup cancelled")
                return False
                
        success = True
        
        # Stop and remove containers
        for container in context.containers:
            try:
                if container.running:
                    print(f"Stopping {container.name}...")
                    subprocess.run(["docker", "stop", container.name], 
                                 capture_output=True, check=True)
                    
                print(f"Removing {container.name}...")
                subprocess.run(["docker", "rm", "-f", container.name], 
                             capture_output=True, check=True)
                             
            except subprocess.CalledProcessError as e:
                print(f"Error removing {container.name}: {e}")
                success = False
                
        # Remove tmux session
        if context.tmux_session:
            try:
                print(f"Removing tmux session {context.tmux_session}...")
                subprocess.run(["tmux", "kill-session", "-t", context.tmux_session], 
                             capture_output=True, check=True)
            except subprocess.CalledProcessError as e:
                print(f"Error removing tmux session: {e}")
                success = False
        
        # Remove from core registry
        try:
            self.core_manager.delete_context(context_name)
            print(f"Removed session '{context_name}' from registry")
        except Exception as e:
            print(f"Warning: Could not remove from registry: {e}")
                
        if success:
            print(f"\nSession '{context_name}' cleanup completed successfully")
        else:
            print(f"\nSession '{context_name}' cleanup completed with some errors")
            
        return success
    
    def export_session_config(self, context_name: str, output_file: str) -> bool:
        """Export session configuration to file"""
        context = self.get_context_details(context_name)
        if not session:
            print(f"Context '{context_name}' not found")
            return False
            
        config = {
            "context_name": context_name,
            "export_date": datetime.now().isoformat(),
            "containers": [asdict(container) for container in context.containers],
            "tmux_session": context.tmux_session,
            "metadata": {
                "total_containers": context.total_containers,
                "running_containers": context.running_containers
            }
        }
        
        try:
            with open(output_file, 'w') as f:
                json.dump(config, f, indent=2)
            print(f"Session configuration exported to {output_file}")
            return True
        except Exception as e:
            print(f"Error exporting configuration: {e}")
            return False
    
    def import_session_config(self, config_file: str) -> bool:
        """Import session configuration from file"""
        try:
            with open(config_file, 'r') as f:
                config = json.load(f)
                
            print(f"Configuration loaded for session: {config['context_name']}")
            print(f"Export date: {config['export_date']}")
            print(f"Containers: {len(config['containers'])}")
            
            # This would need orchestrator integration to actually recreate containers
            print("Note: Import functionality requires orchestrator integration")
            print("Configuration can be used as reference for manual recreation")
            
            return True
            
        except Exception as e:
            print(f"Error importing configuration: {e}")
            return False


def print_sessions_table(contexts: Dict[str, ContextInfo]):
    """Print sessions in a formatted table"""
    if not contexts:
        print("No team contexts found")
        return
        
    print(f"\n{'Session Name':<25} {'Containers':<12} {'Running':<8} {'Tmux':<15} {'Created':<20}")
    print("-" * 85)
    
    for context_name, context in sorted(contexts.items()):
        tmux_status = "✓" if context.tmux_session else "-"
        created = context.created[:19] if context.created else "Unknown"
        
        print(f"{context_name:<25} {context.total_containers:<12} {context.running_containers:<8} {tmux_status:<15} {created:<20}")


def print_context_details(context: ContextInfo):
    """Print detailed session information"""
    print(f"\nSession: {context.name}")
    print(f"Created: {context.created}")
    print(f"Containers: {context.total_containers} total, {context.running_containers} running")
    
    if context.tmux_session:
        print(f"Tmux session: {context.tmux_session}")
    else:
        print("Tmux session: None")
        
    print("\nContainers:")
    for container in context.containers:
        status_icon = "🟢" if container.running else "🔴"
        print(f"  {status_icon} {container.name}")
        print(f"    Role: {container.agent_role}")
        print(f"    Status: {container.status}")
        print(f"    Created: {container.created}")


def main():
    parser = argparse.ArgumentParser(description="Manage Claude orchestrator sessions")
    subparsers = parser.add_subparsers(dest='command', help='Available commands')
    
    # List sessions
    list_parser = subparsers.add_parser('list', help='List all team contexts')
    list_parser.add_argument('--detailed', '-d', action='store_true', 
                           help='Show detailed information')
    
    # Show session info
    info_parser = subparsers.add_parser('info', help='Show detailed session information')
    info_parser.add_argument('context_name', help='Name of the session')
    
    # Health check
    health_parser = subparsers.add_parser('health', help='Check session health')
    health_parser.add_argument('context_name', help='Name of the session')
    health_parser.add_argument('--json', action='store_true', help='Output as JSON')
    
    # Cleanup
    clean_parser = subparsers.add_parser('clean', help='Clean up a session')
    clean_parser.add_argument('context_name', help='Name of the session')
    clean_parser.add_argument('--force', '-f', action='store_true', 
                            help='Skip confirmation prompt')
    
    # Export
    export_parser = subparsers.add_parser('export', help='Export session configuration')
    export_parser.add_argument('context_name', help='Name of the session')
    export_parser.add_argument('output_file', help='Output file path')
    
    # Import
    import_parser = subparsers.add_parser('import', help='Import session configuration')
    import_parser.add_argument('config_file', help='Configuration file path')
    
    args = parser.parse_args()
    
    if not args.command:
        parser.print_help()
        return
        
    manager = SessionCLIManager()
    
    if args.command == 'list':
        contexts = manager.list_contexts()
        if args.detailed:
            for context in contexts.values():
                print_context_details(context)
                print()
        else:
            print_sessions_table(contexts)
            
    elif args.command == 'info':
        context = manager.get_context_details(args.context_name)
        if context:
            print_context_details(context)
        else:
            print(f"Context '{args.context_name}' not found")
            
    elif args.command == 'health':
        health = manager.health_check_context(args.context_name)
        if args.json:
            print(json.dumps(health, indent=2))
        else:
            if "error" in health:
                print(health["error"])
            else:
                print(f"Session: {health['context_name']}")
                print(f"Overall health: {health['overall_health']}")
                
                if health['issues']:
                    print("\nIssues:")
                    for issue in health['issues']:
                        print(f"  - {issue}")
                        
                print(f"\nContainers: {len(health['containers'])}")
                for name, container_health in health['containers'].items():
                    status_icon = "🟢" if container_health['status'] == 'healthy' else "🔴"
                    print(f"  {status_icon} {name}: {container_health['status']}")
                    
    elif args.command == 'clean':
        manager.cleanup_context(args.context_name, args.force)
        
    elif args.command == 'export':
        manager.export_session_config(args.context_name, args.output_file)
        
    elif args.command == 'import':
        manager.import_session_config(args.config_file)


if __name__ == '__main__':
    main()