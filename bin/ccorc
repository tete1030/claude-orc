#!/usr/bin/env python3
"""
Session Management CLI Utility

Command-line tool for managing Claude Multi-Agent Orchestrator persistent contexts.
Provides session discovery, health monitoring, and cleanup capabilities.
"""

import argparse
import json
import sys
import time

from pathlib import Path
from typing import Dict, List, Optional

# Add parent directory to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent))

# Import core modules
try:
    from src.team_context_manager import TeamContextManager
    from src.team_config_loader import TeamConfigLoader
    
    # Import all refactored services
    from src.services.container_discovery_service import (
        ContainerDiscoveryService, ContainerInfo, ContextInfo
    )
    from src.services.tmux_management_service import TmuxManagementService
    from src.services.container_health_service import ContainerHealthService
    from src.services.context_cleanup_service import ContextCleanupService
    from src.services.team_launch_service import TeamLaunchService
    from src.services.port_discovery_service import PortDiscoveryService
    from src.services.layout_detection_service import LayoutDetectionService
    from src.services.orchestrator_factory import OrchestratorFactory
    from src.services.mcp_server_manager import MCPServerManager
    from src.services.signal_handler_service import SignalHandlerService
    from src.services.context_persistence_service import ContextPersistenceService
except ImportError as e:
    print(f"Error: Could not import required modules: {e}", file=sys.stderr)
    sys.exit(1)


class SessionCLIManager:
    """Refactored CLI manager that coordinates services"""
    
    def __init__(self):
        # Core manager
        self.context_manager = TeamContextManager()
        
        # Initialize all services
        self.container_discovery = ContainerDiscoveryService()
        self.tmux_management = TmuxManagementService()
        self.container_health = ContainerHealthService()
        self.context_cleanup = ContextCleanupService(self.tmux_management)
        
        # Services for team launching
        self.port_service = PortDiscoveryService()
        self.layout_service = LayoutDetectionService()
        self.orchestrator_factory = OrchestratorFactory(layout_service=self.layout_service)
        self.mcp_server_manager = MCPServerManager()
        self.signal_handler = SignalHandlerService()
        self.context_persistence = ContextPersistenceService(self.context_manager)
        
        self.team_launch = TeamLaunchService(
            port_service=self.port_service,
            orchestrator_factory=self.orchestrator_factory,
            mcp_server_manager=self.mcp_server_manager,
            signal_handler=self.signal_handler,
            context_persistence=self.context_persistence,
            cleanup_callback=self.cleanup_context
        )
        
        self.team_loader = TeamConfigLoader()
    
    def discover_contexts(self) -> Dict[str, ContextInfo]:
        """Discover all team contexts from running containers"""
        contexts = self.container_discovery.discover_all_containers()
        self.tmux_management.discover_tmux_sessions(contexts)
        return contexts
    
    def list_contexts(self) -> Dict[str, ContextInfo]:
        """List registered team contexts from the context registry"""
        contexts = {}
        
        # Get registered contexts
        registered_contexts = self.context_persistence.list_contexts()
        
        for name, context in registered_contexts.items():
            # Get container names from agents
            container_names = [agent.container for agent in context.agents]
            
            # Check container status
            running = sum(
                1 for container_name in container_names
                if self.container_discovery.check_container_running(container_name)
            )
            
            # Create ContextInfo for registered session
            contexts[name] = ContextInfo(
                name=name,
                containers=[],  # Don't populate full container list for simple listing
                tmux_session=context.tmux_session,
                created=context.created_at,
                total_containers=len(container_names),
                running_containers=running,
            )
        
        return contexts
    
    def get_context_details(self, context_name: str) -> Optional[ContextInfo]:
        """Get detailed information about a specific session"""
        context = self.context_persistence.get_context(context_name)
        if not context:
            return None
        
        # Get container names from agents
        container_names = [agent.container for agent in context.agents]
        
        # Get live container information
        containers = self.container_discovery.get_container_status(container_names)
        
        # Create ContextInfo
        session_info = ContextInfo(
            name=context_name,
            containers=containers,
            tmux_session=context.tmux_session,
            created=context.created_at,
            total_containers=len(containers),
            running_containers=sum(1 for c in containers if c.running),
        )
        
        return session_info
    
    def health_check_context(self, context_name: str) -> Dict[str, any]:
        """Perform health check on session components"""
        context = self.get_context_details(context_name)
        if not context:
            return {"error": f"Context '{context_name}' not found"}
        
        health_status = {
            "context_name": context_name,
            "overall_health": "healthy",
            "containers": {},
            "tmux_session": None,
            "issues": [],
        }
        
        # Check container health
        container_health_results = self.container_health.check_all_containers_health(
            context.containers
        )
        
        health_status["containers"] = container_health_results
        
        # Check for any unhealthy containers
        for container_name, container_health in container_health_results.items():
            if container_health["status"] != "healthy":
                health_status["overall_health"] = "degraded"
                health_status["issues"].extend(container_health.get("issues", []))
        
        # Check tmux session
        if context.tmux_session:
            tmux_health = self.tmux_management.check_tmux_health(context.tmux_session)
            health_status["tmux_session"] = tmux_health
            
            if tmux_health["status"] != "healthy":
                health_status["overall_health"] = "degraded"
                health_status["issues"].extend(tmux_health.get("issues", []))
        
        return health_status
    
    def cleanup_context(self, context_name: str, force: bool = False) -> bool:
        """Clean up a team context"""
        context = self.get_context_details(context_name)
        if not context:
            print(f"Context '{context_name}' not found")
            return False
        
        # Delegate to cleanup service
        success = self.context_cleanup.cleanup_context(context, force)
        
        # Remove from registry
        if success and self.context_persistence.delete_context(context_name):
            print(f"Removed session '{context_name}' from registry")
        else:
            print(f"Warning: Could not remove from registry")
            success = False
        
        return success
    
    def export_session_config(self, context_name: str, output_file: str) -> bool:
        """Export session configuration to file"""
        result = self.context_persistence.save_to_file(context_name, output_file)
        if result:
            print(f"Session configuration exported to {output_file}")
        else:
            print(f"Error: Could not export context '{context_name}'")
        return result
    
    def import_session_config(self, config_file: str) -> bool:
        """Import session configuration from file"""
        result = self.context_persistence.load_from_file(config_file)
        if result:
            print(f"Configuration imported successfully")
            print("Note: Containers need to be recreated manually")
        else:
            print(f"Error importing configuration from {config_file}")
        return result
    
    def list_teams(self) -> List[Dict[str, any]]:
        """List all available team configurations"""
        teams = []
        
        # Search in all configured paths
        for search_path in self.team_loader.search_paths:
            if not search_path.exists():
                continue
            
            # Look for config files
            for team_dir in search_path.glob("*"):
                try:
                    # Try to load to validate
                    config = self.team_loader.load_config(team_dir.name)
                    teams.append(
                        {
                            "name": team_dir.name,
                            "path": str(team_dir / "team.yaml"),
                            "team_name": config.name,
                            "description": config.description,
                            "agents": len(config.agents),
                            "directory": search_path.name,
                        }
                    )
                except Exception as e:
                    # Skip invalid configs
                    print(
                        f"Warning: Skipping invalid config {team_dir.name}: {e}", file=sys.stderr
                    )
        
        return teams
    
    def launch_team(
        self,
        team_name: str,
        context_name: str = None,
        model_override: str = None,
        agent_model_overrides: dict = None,
        force: bool = False,
        debug: bool = False,
        task: str = None,
        auto_cleanup: bool = True,
    ) -> bool:
        """Launch a team configuration"""
        # Handle forced context cleanup here if needed
        if force and context_name and self.context_persistence.get_context(context_name):
            print(f"Forcing cleanup of existing context '{context_name}'...")
            self.cleanup_context(context_name, force=True)
        
        # Delegate to team launch service
        return self.team_launch.launch_team(
            team_name=team_name,
            context_name=context_name,
            model_override=model_override,
            agent_model_overrides=agent_model_overrides,
            force=force,
            debug=debug,
            task=task,
            auto_cleanup=auto_cleanup,
        )


# Utility functions kept for backward compatibility
def print_teams_table(teams: List[Dict[str, any]]):
    """Print teams in a formatted table"""
    from src.cli.teams_command import TeamsListSubcommand
    cmd = TeamsListSubcommand()
    cmd._print_teams_table(teams)


def parse_agent_model_overrides(overrides_list: List[str]) -> Dict[str, str]:
    """Parse agent model override arguments"""
    from src.cli.launch_command import LaunchCommand
    cmd = LaunchCommand()
    return cmd._parse_agent_model_overrides(overrides_list)


def print_sessions_table(contexts: Dict[str, ContextInfo]):
    """Print sessions in a formatted table"""
    from src.cli.list_command import ListCommand
    cmd = ListCommand()
    cmd._print_sessions_table(contexts)


def print_context_details(context: ContextInfo):
    """Print detailed session information"""
    from src.cli.info_command import InfoCommand
    cmd = InfoCommand()
    cmd._print_context_details(context)


def main():
    parser = argparse.ArgumentParser(description="Manage Claude orchestrator sessions")
    
    # Import command registry
    try:
        from src.cli.command_registry import CommandRegistry
        registry = CommandRegistry()
    except ImportError:
        print("Warning: Command registry not available, using legacy command handling")
        # Fall back to old implementation
        return main_legacy(parser)
    
    # Set up parser with commands
    registry.setup_parser(parser)
    
    args = parser.parse_args()
    
    if not hasattr(args, 'command') or not args.command:
        parser.print_help()
        return
    
    # Create manager
    manager = SessionCLIManager()
    
    # Execute command
    exit_code = registry.execute_command(args, manager)
    sys.exit(exit_code)


def main_legacy(parser):
    """Legacy main function for backward compatibility"""
    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    # List sessions
    list_parser = subparsers.add_parser("list", help="List all team contexts")
    list_parser.add_argument(
        "--detailed", "-d", action="store_true", help="Show detailed information"
    )

    # Show session info
    info_parser = subparsers.add_parser("info", help="Show detailed context information")
    info_parser.add_argument("context_name", help="Name of the context")

    # Health check
    health_parser = subparsers.add_parser("health", help="Check context health")
    health_parser.add_argument("context_name", help="Name of the context")
    health_parser.add_argument("--json", action="store_true", help="Output as JSON")

    # Cleanup
    clean_parser = subparsers.add_parser("clean", help="Clean up a context")
    clean_parser.add_argument("context_name", help="Name of the context")
    clean_parser.add_argument("--force", "-f", action="store_true", help="Skip confirmation prompt")

    # Export
    export_parser = subparsers.add_parser("export", help="Export context configuration")
    export_parser.add_argument("context_name", help="Name of the context")
    export_parser.add_argument("output_file", help="Output file path")

    # Import
    import_parser = subparsers.add_parser("import", help="Import context configuration")
    import_parser.add_argument("config_file", help="Configuration file path")

    # Teams subcommand
    teams_parser = subparsers.add_parser("teams", help="Team configuration management")
    teams_subparsers = teams_parser.add_subparsers(dest="teams_command", help="Teams commands")

    # Teams list
    teams_subparsers.add_parser(
        "list", help="List available team configurations"
    )

    # Launch team
    launch_parser = subparsers.add_parser("launch", help="Launch a team configuration")
    launch_parser.add_argument("--team", required=True, help="Team configuration name")
    launch_parser.add_argument("--name", help="Override context name")
    launch_parser.add_argument("--model", help="Override all agents' models")
    launch_parser.add_argument(
        "--agent-model",
        action="append",
        default=[],
        help="Override specific agent model (format: Agent=model)",
    )
    launch_parser.add_argument(
        "--force", "-f", action="store_true", help="Force kill existing session if it exists"
    )
    launch_parser.add_argument("--debug", action="store_true", help="Enable debug mode")
    launch_parser.add_argument("--task", help="Initial task for the team (will be added to Architect prompt)")
    launch_parser.add_argument("--no-auto-cleanup", action="store_true", help="Disable automatic context cleanup on exit")

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        return

    manager = SessionCLIManager()

    if args.command == "list":
        contexts = manager.list_contexts()
        if args.detailed:
            for context in contexts.values():
                print_context_details(context)
                print()
        else:
            print_sessions_table(contexts)

    elif args.command == "info":
        context = manager.get_context_details(args.context_name)
        if context:
            print_context_details(context)
        else:
            print(f"Context '{args.context_name}' not found")

    elif args.command == "health":
        health = manager.health_check_context(args.context_name)
        if args.json:
            print(json.dumps(health, indent=2))
        else:
            if "error" in health:
                print(health["error"])
            else:
                print(f"Context: {health['context_name']}")
                print(f"Overall health: {health['overall_health']}")

                if health["issues"]:
                    print("\nIssues:")
                    for issue in health["issues"]:
                        print(f"  - {issue}")

                print(f"\nContainers: {len(health['containers'])}")
                for name, container_health in health["containers"].items():
                    status_icon = "🟢" if container_health["status"] == "healthy" else "🔴"
                    print(f"  {status_icon} {name}: {container_health['status']}")

    elif args.command == "clean":
        manager.cleanup_context(args.context_name, args.force)

    elif args.command == "export":
        manager.export_session_config(args.context_name, args.output_file)

    elif args.command == "import":
        manager.import_session_config(args.config_file)

    elif args.command == "teams":
        if args.teams_command == "list":
            teams = manager.list_teams()
            print_teams_table(teams)
        else:
            teams_parser.print_help()

    elif args.command == "launch":
        # Parse agent model overrides
        agent_model_overrides = parse_agent_model_overrides(args.agent_model)

        # Launch the team
        success = manager.launch_team(
            team_name=args.team,
            context_name=args.name,
            model_override=args.model,
            agent_model_overrides=agent_model_overrides,
            force=args.force,
            debug=args.debug,
            task=args.task,
            auto_cleanup=not args.no_auto_cleanup,
        )

        if not success:
            sys.exit(1)


if __name__ == "__main__":
    main()