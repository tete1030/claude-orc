#!/usr/bin/env python3
"""
Session Management CLI Utility

Command-line tool for managing Claude Multi-Agent Orchestrator persistent contexts.
Provides session discovery, health monitoring, and cleanup capabilities.
"""

import argparse
import json
import sys
import time

from pathlib import Path
from typing import Dict, List, Optional

# Add parent directory to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent))

# Import core modules
try:
    from src.team_context_manager import TeamContextManager
    from src.team_config_loader import TeamConfigLoader
    
    # Import all refactored services
    from src.services.container_discovery_service import (
        ContainerDiscoveryService, ContainerInfo, ContextInfo
    )
    from src.services.tmux_management_service import TmuxManagementService
    from src.services.container_health_service import ContainerHealthService
    from src.services.context_cleanup_service import ContextCleanupService
    from src.services.team_launch_service import TeamLaunchService
    from src.services.port_discovery_service import PortDiscoveryService
    from src.services.layout_detection_service import LayoutDetectionService
    from src.services.orchestrator_factory import OrchestratorFactory
    from src.services.mcp_server_manager import MCPServerManager
    from src.services.signal_handler_service import SignalHandlerService
    from src.services.context_persistence_service import ContextPersistenceService
except ImportError as e:
    print(f"Error: Could not import required modules: {e}", file=sys.stderr)
    sys.exit(1)


class SessionCLIManager:
    """Refactored CLI manager that coordinates services"""
    
    def __init__(self):
        # Core manager
        self.context_manager = TeamContextManager()
        
        # Initialize all services
        self.container_discovery = ContainerDiscoveryService()
        self.tmux_management = TmuxManagementService()
        self.container_health = ContainerHealthService()
        self.context_cleanup = ContextCleanupService(self.tmux_management)
        
        # Services for team launching
        self.port_service = PortDiscoveryService()
        self.layout_service = LayoutDetectionService()
        self.orchestrator_factory = OrchestratorFactory(layout_service=self.layout_service)
        self.mcp_server_manager = MCPServerManager()
        self.signal_handler = SignalHandlerService()
        self.context_persistence = ContextPersistenceService(self.context_manager)
        
        self.team_launch = TeamLaunchService(
            port_service=self.port_service,
            orchestrator_factory=self.orchestrator_factory,
            mcp_server_manager=self.mcp_server_manager,
            signal_handler=self.signal_handler,
            context_persistence=self.context_persistence,
            cleanup_callback=self.cleanup_context
        )
        
        self.team_loader = TeamConfigLoader()
    
    def discover_contexts(self) -> Dict[str, ContextInfo]:
        """Discover all team contexts from running containers"""
        contexts = self.container_discovery.discover_all_containers()
        self.tmux_management.discover_tmux_sessions(contexts)
        return contexts
    
    def list_contexts(self) -> Dict[str, ContextInfo]:
        """List registered team contexts using runtime Docker discovery"""
        contexts = {}
        
        # Get registered contexts
        registered_contexts = self.context_persistence.list_contexts()
        
        for name, context in registered_contexts.items():
            # Use runtime discovery to find containers for this context
            discovered_containers = self.container_discovery.discover_all_containers()
            
            if name in discovered_containers:
                # Context has running containers
                context_containers = discovered_containers[name]
                contexts[name] = ContextInfo(
                    name=name,
                    containers=[],  # Don't populate full container list for simple listing
                    tmux_session=context.tmux_session,
                    created=context.created_at,
                    total_containers=context_containers.total_containers,
                    running_containers=context_containers.running_containers,
                )
            else:
                # Context registered but no containers found
                contexts[name] = ContextInfo(
                    name=name,
                    containers=[],
                    tmux_session=context.tmux_session,
                    created=context.created_at,
                    total_containers=0,
                    running_containers=0,
                )
        
        return contexts
    
    def get_context_details(self, context_name: str) -> Optional[ContextInfo]:
        """Get detailed information about a specific session using runtime Docker discovery"""
        context = self.context_persistence.get_context(context_name)
        if not context:
            return None
        
        # Use runtime discovery to find containers for this context
        discovered_containers = self.container_discovery.discover_all_containers()
        
        if context_name in discovered_containers:
            # Context has containers - return detailed info
            context_info = discovered_containers[context_name]
            return ContextInfo(
                name=context_name,
                containers=context_info.containers,
                tmux_session=context.tmux_session,
                created=context.created_at,
                total_containers=context_info.total_containers,
                running_containers=context_info.running_containers,
            )
        else:
            # Context registered but no containers found
            return ContextInfo(
                name=context_name,
                containers=[],
                tmux_session=context.tmux_session,
                created=context.created_at,
                total_containers=0,
                running_containers=0,
            )
    
    def health_check_context(self, context_name: str) -> Dict[str, any]:
        """Perform health check on session components"""
        context = self.get_context_details(context_name)
        if not context:
            return {"error": f"Context '{context_name}' not found"}
        
        health_status = {
            "context_name": context_name,
            "overall_health": "healthy",
            "containers": {},
            "tmux_session": None,
            "issues": [],
        }
        
        # Check container health
        container_health_results = self.container_health.check_all_containers_health(
            context.containers
        )
        
        health_status["containers"] = container_health_results
        
        # Check for any unhealthy containers
        for container_name, container_health in container_health_results.items():
            if container_health["status"] != "healthy":
                health_status["overall_health"] = "degraded"
                health_status["issues"].extend(container_health.get("issues", []))
        
        # Check tmux session
        if context.tmux_session:
            tmux_health = self.tmux_management.check_tmux_health(context.tmux_session)
            health_status["tmux_session"] = tmux_health
            
            if tmux_health["status"] != "healthy":
                health_status["overall_health"] = "degraded"
                health_status["issues"].extend(tmux_health.get("issues", []))
        
        return health_status
    
    def cleanup_context(self, context_name: str, force: bool = False) -> bool:
        """Clean up a team context"""
        context = self.get_context_details(context_name)
        if not context:
            print(f"Context '{context_name}' not found")
            return False
        
        # Delegate to cleanup service
        success = self.context_cleanup.cleanup_context(context, force)
        
        # Remove from registry
        if success and self.context_persistence.delete_context(context_name):
            print(f"Removed session '{context_name}' from registry")
        else:
            print(f"Warning: Could not remove from registry")
            success = False
        
        return success
    
    def export_session_config(self, context_name: str, output_file: str) -> bool:
        """Export session configuration to file"""
        result = self.context_persistence.save_to_file(context_name, output_file)
        if result:
            print(f"Session configuration exported to {output_file}")
        else:
            print(f"Error: Could not export context '{context_name}'")
        return result
    
    def import_session_config(self, config_file: str) -> bool:
        """Import session configuration from file"""
        result = self.context_persistence.load_from_file(config_file)
        if result:
            print(f"Configuration imported successfully")
            print("Note: Containers need to be recreated manually")
        else:
            print(f"Error importing configuration from {config_file}")
        return result
    
    def list_teams(self) -> List[Dict[str, any]]:
        """List all available team configurations"""
        teams = []
        
        # Search in all configured paths
        for search_path in self.team_loader.search_paths:
            if not search_path.exists():
                continue
            
            # Look for config files
            for team_dir in search_path.glob("*"):
                try:
                    # Try to load to validate
                    config = self.team_loader.load_config(team_dir.name)
                    teams.append(
                        {
                            "name": team_dir.name,
                            "path": str(team_dir / "team.yaml"),
                            "team_name": config.name,
                            "description": config.description,
                            "agents": len(config.agents),
                            "directory": search_path.name,
                        }
                    )
                except Exception as e:
                    # Skip invalid configs
                    print(
                        f"Warning: Skipping invalid config {team_dir.name}: {e}", file=sys.stderr
                    )
        
        return teams
    
    def launch_team(
        self,
        team_name: str,
        context_name: str = None,
        model_override: str = None,
        agent_model_overrides: dict = None,
        force: bool = False,
        debug: bool = False,
        task: str = None,
        auto_cleanup: bool = True,
        fresh: bool = False,
    ) -> bool:
        """Launch a team configuration"""
        # Handle forced context cleanup here if needed
        if force and context_name and self.context_persistence.get_context(context_name):
            print(f"Forcing cleanup of existing context '{context_name}'...")
            self.cleanup_context(context_name, force=True)
        
        # Delegate to team launch service
        return self.team_launch.launch_team(
            team_name=team_name,
            context_name=context_name,
            model_override=model_override,
            agent_model_overrides=agent_model_overrides,
            force=force,
            debug=debug,
            task=task,
            auto_cleanup=auto_cleanup,
            fresh=fresh,
        )


# Utility functions kept for backward compatibility
def print_teams_table(teams: List[Dict[str, any]]):
    """Print teams in a formatted table"""
    from src.cli.teams_command import TeamsListSubcommand
    cmd = TeamsListSubcommand()
    cmd._print_teams_table(teams)


def parse_agent_model_overrides(overrides_list: List[str]) -> Dict[str, str]:
    """Parse agent model override arguments"""
    from src.cli.launch_command import LaunchCommand
    cmd = LaunchCommand()
    return cmd._parse_agent_model_overrides(overrides_list)


def print_sessions_table(contexts: Dict[str, ContextInfo]):
    """Print sessions in a formatted table"""
    from src.cli.list_command import ListCommand
    cmd = ListCommand()
    cmd._print_sessions_table(contexts)


def print_context_details(context: ContextInfo):
    """Print detailed session information"""
    from src.cli.info_command import InfoCommand
    cmd = InfoCommand()
    cmd._print_context_details(context)


def main():
    parser = argparse.ArgumentParser(description="Manage Claude orchestrator sessions")
    
    # Import command registry
    from src.cli.command_registry import CommandRegistry
    registry = CommandRegistry()
    
    # Set up parser with commands
    registry.setup_parser(parser)
    
    args = parser.parse_args()
    
    if not hasattr(args, 'command') or not args.command:
        parser.print_help()
        return
    
    # Create manager
    manager = SessionCLIManager()
    
    # Execute command
    exit_code = registry.execute_command(args, manager)
    sys.exit(exit_code)




if __name__ == "__main__":
    main()